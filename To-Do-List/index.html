<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-Do-List</title>
    <link rel="stylesheet" href="style.css" type="text/css">
</head>
<body>
    <div class="container">
        <div class="todo-app">
            <h2>To-Do List <img src="images/icon.png" alt="icon"></h2>
            <div class="row">
                <input type="text" id="input-box" placeholder="Add your text">
                <button onclick="addTask()">Add</button>
            </div>
            <ul id="list-container">
                <!--<li class="checked">Task 1</li>
                <li>Task 2</li>
                <li>Task 3</li>-->
            </ul>
        </div>
    </div>
    <script src="script.js"></script>
</body>

</html>







package com.credit.backend.security;

import com.credit.backend.util.JwtUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {

        final String authorizationHeader = request.getHeader("Authorization");

        String email = null;
        String jwt = null;

        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            email = jwtUtil.extractEmail(jwt);
        }

        if (email != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(email);

            if (jwtUtil.validateToken(jwt, userDetails.getUsername())) {
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        chain.doFilter(request, response);
    }
}






package com.credit.backend.service;

import com.credit.backend.dao.*;
import com.credit.backend.dto.*;
import com.credit.backend.model.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class ApplicationService {

    @Autowired
    private ApplicationSubmitterRepository submitterRepository;

    @Autowired
    private ApplicationDetailsRepository detailsRepository;

    @Autowired
    private ApplicationStatusRepository statusRepository;

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public ApplicationDetailResponse submitApplication(ApplicationRequest request, UUID userId, String role) {
        // Create application submitter
        ApplicationSubmitter submitter = new ApplicationSubmitter();
        submitter.setSubmittedByUserOrSalesId(userId);
        submitter.setSubmittedByRole(ApplicationSubmitter.SubmittedByRole.valueOf(role));
        submitter = submitterRepository.save(submitter);

        // Create application details
        ApplicationDetails details = new ApplicationDetails();
        details.setAppId(submitter.getAppId());
        details.setFullName(request.getFullName());
        details.setEmail(request.getEmail());
        details.setPhoneNumber(request.getPhoneNumber());
        details.setDateOfBirth(request.getDateOfBirth());
        details.setAddress(request.getAddress());
        details.setAadhar(request.getAadhar());
        details.setPan(request.getPan());
        details.setIncomeProof(request.getIncomeProof());
        detailsRepository.save(details);

        // Create application status
        ApplicationStatus status = new ApplicationStatus();
        status.setAppId(submitter.getAppId());
        status.setDocumentVerificationStatus(ApplicationStatus.VerificationStatus.IN_PROGRESS);
        status.setOfferStatus(ApplicationStatus.OfferStatus.IN_PROGRESS);
        statusRepository.save(status);

        return mapToDetailResponse(submitter, details, status);
    }

    @Transactional
    public ApplicationDetailResponse updateApplication(UUID appId, ApplicationRequest request) {
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));

        details.setFullName(request.getFullName());
        details.setEmail(request.getEmail());
        details.setPhoneNumber(request.getPhoneNumber());
        details.setDateOfBirth(request.getDateOfBirth());
        details.setAddress(request.getAddress());
        details.setAadhar(request.getAadhar());
        details.setPan(request.getPan());
        details.setIncomeProof(request.getIncomeProof());
        detailsRepository.save(details);

        ApplicationSubmitter submitter = submitterRepository.findById(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));
        ApplicationStatus status = statusRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application status not found"));

        return mapToDetailResponse(submitter, details, status);
    }

    public List<OnboardingResponse> getAllApplications() {
        List<ApplicationSubmitter> submitters = submitterRepository.findAll();

        return submitters.stream().map(submitter -> {
            ApplicationDetails details = detailsRepository.findByAppId(submitter.getAppId()).orElse(null);
            ApplicationStatus status = statusRepository.findByAppId(submitter.getAppId()).orElse(null);

            OnboardingResponse response = new OnboardingResponse();
            response.setAppId(submitter.getAppId());
            response.setUserId(submitter.getSubmittedByUserOrSalesId());
            response.setFullName(details != null ? details.getFullName() : "N/A");
            response.setPhoneNumber(details != null ? details.getPhoneNumber() : "N/A");
            response.setStatus(status != null ? status.getDocumentVerificationStatus().name() : "N/A");
            response.setSubmittedBy(submitter.getSubmittedByRole().name());
            response.setSubmittedAt(submitter.getSubmittedAt());

            return response;
        }).collect(Collectors.toList());
    }

    public ApplicationDetailResponse getApplicationById(UUID appId) {
        ApplicationSubmitter submitter = submitterRepository.findById(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application details not found"));
        ApplicationStatus status = statusRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application status not found"));

        return mapToDetailResponse(submitter, details, status);
    }

    public List<ApplicationDetailResponse> getApplicationsByUserId(UUID userId) {
        List<ApplicationSubmitter> submitters = submitterRepository.findBySubmittedByUserOrSalesId(userId);

        return submitters.stream().map(submitter -> {
            ApplicationDetails details = detailsRepository.findByAppId(submitter.getAppId()).orElse(null);
            ApplicationStatus status = statusRepository.findByAppId(submitter.getAppId()).orElse(null);

            if (details != null && status != null) {
                return mapToDetailResponse(submitter, details, status);
            }
            return null;
        }).filter(Objects::nonNull).collect(Collectors.toList());
    }

    private ApplicationDetailResponse mapToDetailResponse(ApplicationSubmitter submitter,
                                                          ApplicationDetails details,
                                                          ApplicationStatus status) {
        ApplicationDetailResponse response = new ApplicationDetailResponse();
        response.setAppId(submitter.getAppId());
        response.setFullName(details.getFullName());
        response.setEmail(details.getEmail());
        response.setPhoneNumber(details.getPhoneNumber());
        response.setDateOfBirth(details.getDateOfBirth());
        response.setAddress(details.getAddress());
        response.setAadhar(details.getAadhar());
        response.setPan(details.getPan());
        response.setIncomeProof(details.getIncomeProof());
        response.setDocumentVerificationStatus(status.getDocumentVerificationStatus().name());
        response.setOfferStatus(status.getOfferStatus().name());
        response.setSubmittedByRole(submitter.getSubmittedByRole().name());
        response.setSubmittedById(submitter.getSubmittedByUserOrSalesId());
        response.setSubmittedAt(submitter.getSubmittedAt());
        response.setUpdatedAt(status.getUpdatedAt());

        return response;
    }
}





package com.credit.backend.service;

import com.credit.backend.dao.UserRepository;
import com.credit.backend.dto.AuthResponse;
import com.credit.backend.dto.LoginRequest;
import com.credit.backend.dto.SignUpRequest;
import com.credit.backend.model.User;
import com.credit.backend.util.JwtUtil;
import com.credit.backend.util.PasswordEncoderUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import java.util.Collections;

@Service
public class AuthService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoderUtil passwordEncoderUtil;

    @Autowired
    private JwtUtil jwtUtil;

    public AuthResponse signUp(SignUpRequest request) {
        // Check if user already exists
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new RuntimeException("Email already exists");
        }

        // Create new user
        User user = new User();
        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoderUtil.encode(request.getPassword()));
        user.setRole(User.Role.USER);

        user = userRepository.save(user);

        // Generate token
        String token = jwtUtil.generateToken(user.getEmail(), user.getUserId(), user.getRole().name());

        return new AuthResponse(token, user.getUserId(), user.getEmail(),
                user.getFirstName(), user.getLastName(), user.getRole().name());
    }

    public AuthResponse login(LoginRequest request) {
        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new RuntimeException("Invalid email or password"));

        if (!passwordEncoderUtil.matches(request.getPassword(), user.getPassword())) {
            throw new RuntimeException("Invalid email or password");
        }

        String token = jwtUtil.generateToken(user.getEmail(), user.getUserId(), user.getRole().name());

        return new AuthResponse(token, user.getUserId(), user.getEmail(),
                user.getFirstName(), user.getLastName(), user.getRole().name());
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name()))
        );
    }
}




package com.credit.backend.service;

import com.credit.backend.dao.ApplicationStatusRepository;
import com.credit.backend.dao.ApplicationDetailsRepository;
import com.credit.backend.dao.ApplicationSubmitterRepository;
import com.credit.backend.dto.ApplicationDetailResponse;
import com.credit.backend.dto.DocumentVerificationRequest;
import com.credit.backend.model.ApplicationStatus;
import com.credit.backend.model.ApplicationDetails;
import com.credit.backend.model.ApplicationSubmitter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class DocumentVerificationService {

    @Autowired
    private ApplicationStatusRepository statusRepository;

    @Autowired
    private ApplicationDetailsRepository detailsRepository;

    @Autowired
    private ApplicationSubmitterRepository submitterRepository;

    public List<ApplicationDetailResponse> getPendingVerifications() {
        List<ApplicationStatus> pendingStatuses = statusRepository
                .findByDocumentVerificationStatus(ApplicationStatus.VerificationStatus.IN_PROGRESS);

        return pendingStatuses.stream().map(status -> {
            ApplicationDetails details = detailsRepository.findByAppId(status.getAppId()).orElse(null);
            ApplicationSubmitter submitter = submitterRepository.findById(status.getAppId()).orElse(null);

            if (details != null && submitter != null) {
                return mapToDetailResponse(submitter, details, status);
            }
            return null;
        }).filter(Objects::nonNull).collect(Collectors.toList());
    }

    @Transactional
    public ApplicationDetailResponse verifyDocument(DocumentVerificationRequest request) {
        ApplicationStatus status = statusRepository.findByAppId(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application not found"));

        if ("APPROVED".equalsIgnoreCase(request.getAction())) {
            status.setDocumentVerificationStatus(ApplicationStatus.VerificationStatus.APPROVED);
            status.setDocumentRejectReason(null);
        } else if ("REJECTED".equalsIgnoreCase(request.getAction())) {
            status.setDocumentVerificationStatus(ApplicationStatus.VerificationStatus.REJECTED);
            status.setDocumentRejectReason(request.getRejectReason());
        } else {
            throw new RuntimeException("Invalid action. Use APPROVED or REJECTED");
        }

        statusRepository.save(status);

        ApplicationDetails details = detailsRepository.findByAppId(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application details not found"));
        ApplicationSubmitter submitter = submitterRepository.findById(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application submitter not found"));

        return mapToDetailResponse(submitter, details, status);
    }

    private ApplicationDetailResponse mapToDetailResponse(ApplicationSubmitter submitter,
                                                          ApplicationDetails details,
                                                          ApplicationStatus status) {
        ApplicationDetailResponse response = new ApplicationDetailResponse();
        response.setAppId(submitter.getAppId());
        response.setFullName(details.getFullName());
        response.setEmail(details.getEmail());
        response.setPhoneNumber(details.getPhoneNumber());
        response.setDateOfBirth(details.getDateOfBirth());
        response.setAddress(details.getAddress());
        response.setAadhar(details.getAadhar());
        response.setPan(details.getPan());
        response.setIncomeProof(details.getIncomeProof());
        response.setDocumentVerificationStatus(status.getDocumentVerificationStatus().name());
        response.setOfferStatus(status.getOfferStatus().name());
        response.setSubmittedByRole(submitter.getSubmittedByRole().name());
        response.setSubmittedById(submitter.getSubmittedByUserOrSalesId());
        response.setSubmittedAt(submitter.getSubmittedAt());
        response.setUpdatedAt(status.getUpdatedAt());

        return response;
    }
}






package com.credit.backend.service;

import com.credit.backend.dao.ApplicationStatusRepository;
import com.credit.backend.dao.ApplicationDetailsRepository;
import com.credit.backend.dao.ApplicationSubmitterRepository;
import com.credit.backend.dto.ApplicationDetailResponse;
import com.credit.backend.dto.OfferGenerationRequest;
import com.credit.backend.model.ApplicationStatus;
import com.credit.backend.model.ApplicationDetails;
import com.credit.backend.model.ApplicationSubmitter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class OfferGenerationService {

    @Autowired
    private ApplicationStatusRepository statusRepository;

    @Autowired
    private ApplicationDetailsRepository detailsRepository;

    @Autowired
    private ApplicationSubmitterRepository submitterRepository;

    public List<ApplicationDetailResponse> getApprovedForOffer() {
        // Get applications where document verification is APPROVED and offer is IN_PROGRESS
        List<ApplicationStatus> approvedStatuses = statusRepository
                .findByDocumentVerificationStatusAndOfferStatus(
                        ApplicationStatus.VerificationStatus.APPROVED,
                        ApplicationStatus.OfferStatus.IN_PROGRESS
                );

        return approvedStatuses.stream().map(status -> {
            ApplicationDetails details = detailsRepository.findByAppId(status.getAppId()).orElse(null);
            ApplicationSubmitter submitter = submitterRepository.findById(status.getAppId()).orElse(null);

            if (details != null && submitter != null) {
                return mapToDetailResponse(submitter, details, status);
            }
            return null;
        }).filter(Objects::nonNull).collect(Collectors.toList());
    }

    public Map<String, Object> generateCreditScore(UUID appId) {
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));

        // Dummy credit score generation logic
        Random random = new Random();
        int creditScore = 300 + random.nextInt(551); // Score between 300-850

        String creditRating;
        if (creditScore >= 750) {
            creditRating = "Excellent";
        } else if (creditScore >= 700) {
            creditRating = "Good";
        } else if (creditScore >= 650) {
            creditRating = "Fair";
        } else if (creditScore >= 600) {
            creditRating = "Poor";
        } else {
            creditRating = "Very Poor";
        }

        Map<String, Object> creditInfo = new HashMap<>();
        creditInfo.put("appId", appId);
        creditInfo.put("fullName", details.getFullName());
        creditInfo.put("creditScore", creditScore);
        creditInfo.put("creditRating", creditRating);
        creditInfo.put("generatedAt", new Date());

        return creditInfo;
    }

    @Transactional
    public ApplicationDetailResponse processOffer(OfferGenerationRequest request) {
        ApplicationStatus status = statusRepository.findByAppId(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application not found"));

        // Check if document verification is approved
        if (status.getDocumentVerificationStatus() != ApplicationStatus.VerificationStatus.APPROVED) {
            throw new RuntimeException("Document verification must be approved before generating offer");
        }

        if ("APPROVED".equalsIgnoreCase(request.getAction())) {
            status.setOfferStatus(ApplicationStatus.OfferStatus.APPROVED);
            status.setOfferRejectReason(null);
        } else if ("REJECTED".equalsIgnoreCase(request.getAction())) {
            status.setOfferStatus(ApplicationStatus.OfferStatus.REJECTED);
            status.setOfferRejectReason(request.getRejectReason());
        } else {
            throw new RuntimeException("Invalid action. Use APPROVED or REJECTED");
        }

        statusRepository.save(status);

        ApplicationDetails details = detailsRepository.findByAppId(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application details not found"));
        ApplicationSubmitter submitter = submitterRepository.findById(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application submitter not found"));

        return mapToDetailResponse(submitter, details, status);
    }

    private ApplicationDetailResponse mapToDetailResponse(ApplicationSubmitter submitter,
                                                          ApplicationDetails details,
                                                          ApplicationStatus status) {
        ApplicationDetailResponse response = new ApplicationDetailResponse();
        response.setAppId(submitter.getAppId());
        response.setFullName(details.getFullName());
        response.setEmail(details.getEmail());
        response.setPhoneNumber(details.getPhoneNumber());
        response.setDateOfBirth(details.getDateOfBirth());
        response.setAddress(details.getAddress());
        response.setAadhar(details.getAadhar());
        response.setPan(details.getPan());
        response.setIncomeProof(details.getIncomeProof());
        response.setDocumentVerificationStatus(status.getDocumentVerificationStatus().name());
        response.setOfferStatus(status.getOfferStatus().name());
        response.setSubmittedByRole(submitter.getSubmittedByRole().name());
        response.setSubmittedById(submitter.getSubmittedByUserOrSalesId());
        response.setSubmittedAt(submitter.getSubmittedAt());
        response.setUpdatedAt(status.getUpdatedAt());

        return response;
    }
}





package com.credit.backend.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

@Component
public class JwtUtil {

    @Value("${jwt.secret:mySecretKeyForJWTTokenGenerationAndValidation12345}")
    private String secret;

    @Value("${jwt.expiration:86400000}") // 24 hours
    private Long expiration;

    private Key getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }

    public String extractEmail(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(String email, UUID userId, String role) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId.toString());
        claims.put("role", role);
        return createToken(claims, email);
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public Boolean validateToken(String token, String email) {
        final String extractedEmail = extractEmail(token);
        return (extractedEmail.equals(email) && !isTokenExpired(token));
    }
}



package com.credit.backend.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

@Component
public class JwtUtil {

    @Value("${jwt.secret:mySecretKeyForJWTTokenGenerationAndValidation12345}")
    private String secret;

    @Value("${jwt.expiration:86400000}") // 24 hours
    private Long expiration;

    private Key getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }

    public String extractEmail(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(String email, UUID userId, String role) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId.toString());
        claims.put("role", role);
        return createToken(claims, email);
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public Boolean validateToken(String token, String email) {
        final String extractedEmail = extractEmail(token);
        return (extractedEmail.equals(email) && !isTokenExpired(token));
    }
}





import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;

@SpringBootApplication(scanBasePackages = {"com.credit.backend"})
@EntityScan(basePackages = "com.credit.backend.model")
@EnableJpaRepositories(basePackages = "com.credit.backend.dao")
@EnableMethodSecurity // ADDED: Enable method-level security





# Server Configuration
server.port=8080

# Database Configuration
spring.datasource.url=jdbc:postgresql://localhost:5432/credit_card_db
spring.datasource.username=postgres
spring.datasource.password=1234
spring.datasource.driver-class-name=org.postgresql.Driver

# JPA/Hibernate Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=true

# JWT Configuration
jwt.secret=mySecretKeyForJWTTokenGenerationAndValidation12345
jwt.expiration=86400000

# Logging
logging.level.org.springframework.security=DEBUG
logging.level.com.credit.backend=DEBUG








<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- Spring Boot Starter Validation -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<scope>runtime</scope>
		</dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.11.5</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.11.5</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Spring Security Test -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

