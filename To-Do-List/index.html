<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>To-Do-List</title>
    <link rel="stylesheet" href="style.css" type="text/css">
</head>
<body>
    <div class="container">
        <div class="todo-app">
            <h2>To-Do List <img src="images/icon.png" alt="icon"></h2>
            <div class="row">
                <input type="text" id="input-box" placeholder="Add your text">
                <button onclick="addTask()">Add</button>
            </div>
            <ul id="list-container">
                <!--<li class="checked">Task 1</li>
                <li>Task 2</li>
                <li>Task 3</li>-->
            </ul>
        </div>
    </div>
    <script src="script.js"></script>
</body>

</html>



//

package com.credit.backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "application_details")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApplicationDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "app_id", nullable = false)
    private UUID appId;

    @Column(name = "full_name", nullable = false, length = 100)
    private String fullName;

    @Column(name = "email", nullable = false, length = 100)
    private String email;

    @Column(name = "phone_number", nullable = false, length = 20)
    private String phoneNumber;

    @Column(name = "date_of_birth", nullable = false)
    private LocalDate dateOfBirth;

    @Column(name = "address", nullable = false, columnDefinition = "TEXT")
    private String address;

    // FIXED: Use @JdbcTypeCode for Hibernate 6.x
    @JdbcTypeCode(SqlTypes.BINARY)
    @Column(name = "aadhar_pdf")
    private byte[] aadharPdf;

    @Column(name = "aadhar_filename", length = 255)
    private String aadharFilename;

    @JdbcTypeCode(SqlTypes.BINARY)
    @Column(name = "pan_pdf")
    private byte[] panPdf;

    @Column(name = "pan_filename", length = 255)
    private String panFilename;

    @JdbcTypeCode(SqlTypes.BINARY)
    @Column(name = "income_proof_pdf")
    private byte[] incomeProofPdf;

    @Column(name = "income_proof_filename", length = 255)
    private String incomeProofFilename;

    @Enumerated(EnumType.STRING)
    @Column(name = "card_type", length = 20)
    private CardType cardType;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    public enum CardType {
        GOLD, SILVER, PLATINUM
    }

    @PrePersist
    protected void onCreate() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
    }
}




package com.credit.backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "application_status")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApplicationStatus {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "status_id")
    private Long statusId;

    @Column(name = "app_id", nullable = false, unique = true)
    private UUID appId;

    @Enumerated(EnumType.STRING)
    @Column(name = "document_verification_status", nullable = false)
    private VerificationStatus documentVerificationStatus = VerificationStatus.IN_PROGRESS;

    @Column(name = "document_reject_reason", columnDefinition = "TEXT")
    private String documentRejectReason;

    @Enumerated(EnumType.STRING)
    @Column(name = "offer_status", nullable = false)
    private OfferStatus offerStatus = OfferStatus.IN_PROGRESS;

    @Column(name = "offer_reject_reason", columnDefinition = "TEXT")
    private String offerRejectReason;

    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt = LocalDateTime.now();

    public enum VerificationStatus {
        IN_PROGRESS, APPROVED, REJECTED
    }

    public enum OfferStatus {
        IN_PROGRESS, APPROVED, REJECTED
    }

    @PrePersist
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
}





	package com.credit.backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "application_submitter")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApplicationSubmitter {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "app_id")
    private UUID appId;

    @Column(name = "submitted_by_user_or_sales_id", nullable = false)
    private UUID submittedByUserOrSalesId;

    @Enumerated(EnumType.STRING)
    @Column(name = "submitted_by_role", nullable = false)
    private SubmittedByRole submittedByRole;

    @Column(name = "submitted_at", nullable = false, updatable = false)
    private LocalDateTime submittedAt = LocalDateTime.now();

    public enum SubmittedByRole {
        USER, SALES
    }

    @PrePersist
    protected void onCreate() {
        submittedAt = LocalDateTime.now();
    }
}





package com.credit.backend.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.time.LocalDateTime;
import java.util.UUID;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "user_id")
    private UUID userId;

    @Column(name = "first_name", nullable = false, length = 50)
    private String firstName;

    @Column(name = "last_name", nullable = false, length = 50)
    private String lastName;

    @Column(name = "email", nullable = false, unique = true, length = 100)
    private String email;

    @Column(name = "password", nullable = false, length = 255)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(name = "role", nullable = false)
    private Role role = Role.USER;

    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt = LocalDateTime.now();

    public enum Role {
        USER, SALES
    }

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
    }
}





package com.credit.backend.security;

import com.credit.backend.util.JwtUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;
import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Autowired
    private JwtUtil jwtUtil;

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws ServletException, IOException {

        final String authorizationHeader = request.getHeader("Authorization");

        String email = null;
        String jwt = null;

        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            jwt = authorizationHeader.substring(7);
            email = jwtUtil.extractEmail(jwt);
        }

        if (email != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(email);

            if (jwtUtil.validateToken(jwt, userDetails.getUsername())) {
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        chain.doFilter(request, response);
    }
}






package com.credit.backend.service;

import com.credit.backend.dao.*;
import com.credit.backend.dto.*;
import com.credit.backend.model.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class ApplicationService {

    @Autowired
    private ApplicationSubmitterRepository submitterRepository;

    @Autowired
    private ApplicationDetailsRepository detailsRepository;

    @Autowired
    private ApplicationStatusRepository statusRepository;

    @Autowired
    private UserRepository userRepository;

    @Transactional
    public ApplicationDetailResponse submitApplication(
            String fullName, String email, String phoneNumber, String dateOfBirth,
            String address, String cardType,
            MultipartFile aadharPdf, MultipartFile panPdf, MultipartFile incomeProofPdf,
            UUID userId, String role) throws IOException {

        // Validate PDF files
        validatePdfFile(aadharPdf, "Aadhar");
        validatePdfFile(panPdf, "PAN");
        if (incomeProofPdf != null && !incomeProofPdf.isEmpty()) {
            validatePdfFile(incomeProofPdf, "Income Proof");
        }

        // Create application submitter
        ApplicationSubmitter submitter = new ApplicationSubmitter();
        submitter.setSubmittedByUserOrSalesId(userId);
        submitter.setSubmittedByRole(ApplicationSubmitter.SubmittedByRole.valueOf(role));
        submitter = submitterRepository.save(submitter);

        // Create application details
        ApplicationDetails details = new ApplicationDetails();
        details.setAppId(submitter.getAppId());
        details.setFullName(fullName);
        details.setEmail(email);
        details.setPhoneNumber(phoneNumber);
        details.setDateOfBirth(LocalDate.parse(dateOfBirth));
        details.setAddress(address);

        // Store PDF files
        details.setAadharPdf(aadharPdf.getBytes());
        details.setAadharFilename(aadharPdf.getOriginalFilename());

        details.setPanPdf(panPdf.getBytes());
        details.setPanFilename(panPdf.getOriginalFilename());

        if (incomeProofPdf != null && !incomeProofPdf.isEmpty()) {
            details.setIncomeProofPdf(incomeProofPdf.getBytes());
            details.setIncomeProofFilename(incomeProofPdf.getOriginalFilename());
        }

        // Set card type
        details.setCardType(ApplicationDetails.CardType.valueOf(cardType));

        detailsRepository.save(details);

        // Create application status
        ApplicationStatus status = new ApplicationStatus();
        status.setAppId(submitter.getAppId());
        status.setDocumentVerificationStatus(ApplicationStatus.VerificationStatus.IN_PROGRESS);
        status.setOfferStatus(ApplicationStatus.OfferStatus.IN_PROGRESS);
        statusRepository.save(status);

        return mapToDetailResponse(submitter, details, status);
    }

    @Transactional
    public ApplicationDetailResponse updateApplication(
            UUID appId, String fullName, String email, String phoneNumber,
            String dateOfBirth, String address, String cardType,
            MultipartFile aadharPdf, MultipartFile panPdf, MultipartFile incomeProofPdf) throws IOException {

        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));

        details.setFullName(fullName);
        details.setEmail(email);
        details.setPhoneNumber(phoneNumber);
        details.setDateOfBirth(LocalDate.parse(dateOfBirth));
        details.setAddress(address);
        details.setCardType(ApplicationDetails.CardType.valueOf(cardType));

        // Update files only if new files are provided
        if (aadharPdf != null && !aadharPdf.isEmpty()) {
            validatePdfFile(aadharPdf, "Aadhar");
            details.setAadharPdf(aadharPdf.getBytes());
            details.setAadharFilename(aadharPdf.getOriginalFilename());
        }

        if (panPdf != null && !panPdf.isEmpty()) {
            validatePdfFile(panPdf, "PAN");
            details.setPanPdf(panPdf.getBytes());
            details.setPanFilename(panPdf.getOriginalFilename());
        }

        if (incomeProofPdf != null && !incomeProofPdf.isEmpty()) {
            validatePdfFile(incomeProofPdf, "Income Proof");
            details.setIncomeProofPdf(incomeProofPdf.getBytes());
            details.setIncomeProofFilename(incomeProofPdf.getOriginalFilename());
        }

        detailsRepository.save(details);

        ApplicationSubmitter submitter = submitterRepository.findById(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));
        ApplicationStatus status = statusRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application status not found"));

        return mapToDetailResponse(submitter, details, status);
    }

    public List<OnboardingResponse> getAllApplications() {
        List<ApplicationSubmitter> submitters = submitterRepository.findAll();

        return submitters.stream().map(submitter -> {
            ApplicationDetails details = detailsRepository.findByAppId(submitter.getAppId()).orElse(null);
            ApplicationStatus status = statusRepository.findByAppId(submitter.getAppId()).orElse(null);

            OnboardingResponse response = new OnboardingResponse();
            response.setAppId(submitter.getAppId());
            response.setUserId(submitter.getSubmittedByUserOrSalesId());
            response.setFullName(details != null ? details.getFullName() : "N/A");
            response.setPhoneNumber(details != null ? details.getPhoneNumber() : "N/A");
            response.setStatus(status != null ? status.getDocumentVerificationStatus().name() : "N/A");
            response.setSubmittedBy(submitter.getSubmittedByRole().name());
            response.setSubmittedAt(submitter.getSubmittedAt());

            return response;
        }).collect(Collectors.toList());
    }

    public ApplicationDetailResponse getApplicationById(UUID appId) {
        ApplicationSubmitter submitter = submitterRepository.findById(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application details not found"));
        ApplicationStatus status = statusRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application status not found"));

        return mapToDetailResponse(submitter, details, status);
    }

    public List<ApplicationDetailResponse> getApplicationsByUserId(UUID userId) {
        List<ApplicationSubmitter> submitters = submitterRepository.findBySubmittedByUserOrSalesId(userId);

        return submitters.stream().map(submitter -> {
            ApplicationDetails details = detailsRepository.findByAppId(submitter.getAppId()).orElse(null);
            ApplicationStatus status = statusRepository.findByAppId(submitter.getAppId()).orElse(null);

            if (details != null && status != null) {
                return mapToDetailResponse(submitter, details, status);
            }
            return null;
        }).filter(Objects::nonNull).collect(Collectors.toList());
    }

    // NEW: Methods to retrieve PDF files
    public byte[] getAadharPdf(UUID appId) {
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));
        if (details.getAadharPdf() == null) {
            throw new RuntimeException("Aadhar PDF not found");
        }
        return details.getAadharPdf();
    }

    public String getAadharFilename(UUID appId) {
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));
        return details.getAadharFilename();
    }

    public byte[] getPanPdf(UUID appId) {
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));
        if (details.getPanPdf() == null) {
            throw new RuntimeException("PAN PDF not found");
        }
        return details.getPanPdf();
    }

    public String getPanFilename(UUID appId) {
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));
        return details.getPanFilename();
    }

    public byte[] getIncomeProofPdf(UUID appId) {
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));
        if (details.getIncomeProofPdf() == null) {
            throw new RuntimeException("Income Proof PDF not found");
        }
        return details.getIncomeProofPdf();
    }

    public String getIncomeProofFilename(UUID appId) {
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));
        return details.getIncomeProofFilename();
    }

    private void validatePdfFile(MultipartFile file, String fieldName) {
        if (file.isEmpty()) {
            throw new RuntimeException(fieldName + " file is required");
        }
        if (!"application/pdf".equals(file.getContentType())) {
            throw new RuntimeException(fieldName + " must be a PDF file");
        }
        // Max 5MB file size
        if (file.getSize() > 5 * 1024 * 1024) {
            throw new RuntimeException(fieldName + " file size must be less than 5MB");
        }
    }

    private ApplicationDetailResponse mapToDetailResponse(ApplicationSubmitter submitter,
                                                          ApplicationDetails details,
                                                          ApplicationStatus status) {
        ApplicationDetailResponse response = new ApplicationDetailResponse();
        response.setAppId(submitter.getAppId());
        response.setFullName(details.getFullName());
        response.setEmail(details.getEmail());
        response.setPhoneNumber(details.getPhoneNumber());
        response.setDateOfBirth(details.getDateOfBirth());
        response.setAddress(details.getAddress());

        // Set filenames (not the actual bytes)
        response.setAadharFilename(details.getAadharFilename());
        response.setPanFilename(details.getPanFilename());
        response.setIncomeProofFilename(details.getIncomeProofFilename());

        // Set card type
        response.setCardType(details.getCardType() != null ? details.getCardType().name() : null);

        response.setDocumentVerificationStatus(status.getDocumentVerificationStatus().name());
        response.setOfferStatus(status.getOfferStatus().name());
        response.setSubmittedByRole(submitter.getSubmittedByRole().name());
        response.setSubmittedById(submitter.getSubmittedByUserOrSalesId());
        response.setSubmittedAt(submitter.getSubmittedAt());
        response.setUpdatedAt(status.getUpdatedAt());

        return response;
    }
}





package com.credit.backend.service;

import com.credit.backend.dao.UserRepository;
import com.credit.backend.dto.AuthResponse;
import com.credit.backend.dto.LoginRequest;
import com.credit.backend.dto.SignUpRequest;
import com.credit.backend.model.User;
import com.credit.backend.util.JwtUtil;
import com.credit.backend.util.PasswordEncoderUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import java.util.Collections;

@Service
public class AuthService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoderUtil passwordEncoderUtil;

    @Autowired
    private JwtUtil jwtUtil;

    public AuthResponse signUp(SignUpRequest request) {
        // Check if user already exists
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new RuntimeException("Email already exists");
        }

        // Create new user
        User user = new User();
        user.setFirstName(request.getFirstName());
        user.setLastName(request.getLastName());
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoderUtil.encode(request.getPassword()));
        user.setRole(User.Role.USER);

        user = userRepository.save(user);

        // Generate token
        String token = jwtUtil.generateToken(user.getEmail(), user.getUserId(), user.getRole().name());

        return new AuthResponse(token, user.getUserId(), user.getEmail(),
                user.getFirstName(), user.getLastName(), user.getRole().name());
    }

    public AuthResponse login(LoginRequest request) {
        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> new RuntimeException("Invalid email or password"));

        if (!passwordEncoderUtil.matches(request.getPassword(), user.getPassword())) {
            throw new RuntimeException("Invalid email or password");
        }

        String token = jwtUtil.generateToken(user.getEmail(), user.getUserId(), user.getRole().name());

        return new AuthResponse(token, user.getUserId(), user.getEmail(),
                user.getFirstName(), user.getLastName(), user.getRole().name());
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        return new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                Collections.singletonList(new SimpleGrantedAuthority(user.getRole().name()))
        );
    }
}


package com.credit.backend.service;

import com.credit.backend.dao.ApplicationStatusRepository;
import com.credit.backend.dao.ApplicationDetailsRepository;
import com.credit.backend.dao.ApplicationSubmitterRepository;
import com.credit.backend.dto.ApplicationDetailResponse;
import com.credit.backend.dto.DocumentVerificationRequest;
import com.credit.backend.model.ApplicationStatus;
import com.credit.backend.model.ApplicationDetails;
import com.credit.backend.model.ApplicationSubmitter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class DocumentVerificationService {

    @Autowired
    private ApplicationStatusRepository statusRepository;

    @Autowired
    private ApplicationDetailsRepository detailsRepository;

    @Autowired
    private ApplicationSubmitterRepository submitterRepository;

    // REPLACE the getPendingVerifications() method with this:
    public List<ApplicationDetailResponse> getPendingVerifications() {
        // Get ALL application statuses (not just IN_PROGRESS)
        List<ApplicationStatus> allStatuses = statusRepository.findAll();

        return allStatuses.stream().map(status -> {
            ApplicationDetails details = detailsRepository.findByAppId(status.getAppId()).orElse(null);
            ApplicationSubmitter submitter = submitterRepository.findById(status.getAppId()).orElse(null);

            if (details != null && submitter != null) {
                return mapToDetailResponse(submitter, details, status);
            }
            return null;
        }).filter(Objects::nonNull).collect(Collectors.toList());
    }

    @Transactional
    public ApplicationDetailResponse verifyDocument(DocumentVerificationRequest request) {
        ApplicationStatus status = statusRepository.findByAppId(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application not found"));

        if ("APPROVED".equalsIgnoreCase(request.getAction())) {
            status.setDocumentVerificationStatus(ApplicationStatus.VerificationStatus.APPROVED);
            status.setDocumentRejectReason(null);
        } else if ("REJECTED".equalsIgnoreCase(request.getAction())) {
            status.setDocumentVerificationStatus(ApplicationStatus.VerificationStatus.REJECTED);
            status.setDocumentRejectReason(request.getRejectReason());
        } else {
            throw new RuntimeException("Invalid action. Use APPROVED or REJECTED");
        }

        statusRepository.save(status);

        ApplicationDetails details = detailsRepository.findByAppId(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application details not found"));
        ApplicationSubmitter submitter = submitterRepository.findById(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application submitter not found"));

        return mapToDetailResponse(submitter, details, status);
    }

    private ApplicationDetailResponse mapToDetailResponse(ApplicationSubmitter submitter,
                                                          ApplicationDetails details,
                                                          ApplicationStatus status) {
        ApplicationDetailResponse response = new ApplicationDetailResponse();
        response.setAppId(submitter.getAppId());
        response.setFullName(details.getFullName());
        response.setEmail(details.getEmail());
        response.setPhoneNumber(details.getPhoneNumber());
        response.setDateOfBirth(details.getDateOfBirth());
        response.setAddress(details.getAddress());

        // FIXED: Use filename getters
        response.setAadharFilename(details.getAadharFilename());
        response.setPanFilename(details.getPanFilename());
        response.setIncomeProofFilename(details.getIncomeProofFilename());

        // NEW: Set card type
        response.setCardType(details.getCardType() != null ? details.getCardType().name() : null);

        response.setDocumentVerificationStatus(status.getDocumentVerificationStatus().name());
        response.setOfferStatus(status.getOfferStatus().name());
        response.setSubmittedByRole(submitter.getSubmittedByRole().name());
        response.setSubmittedById(submitter.getSubmittedByUserOrSalesId());
        response.setSubmittedAt(submitter.getSubmittedAt());
        response.setUpdatedAt(status.getUpdatedAt());

        return response;
    }
}


package com.credit.backend.service;

import com.credit.backend.dao.ApplicationStatusRepository;
import com.credit.backend.dao.ApplicationDetailsRepository;
import com.credit.backend.dao.ApplicationSubmitterRepository;
import com.credit.backend.dto.ApplicationDetailResponse;
import com.credit.backend.dto.OfferGenerationRequest;
import com.credit.backend.model.ApplicationStatus;
import com.credit.backend.model.ApplicationDetails;
import com.credit.backend.model.ApplicationSubmitter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class OfferGenerationService {

    @Autowired
    private ApplicationStatusRepository statusRepository;

    @Autowired
    private ApplicationDetailsRepository detailsRepository;

    @Autowired
    private ApplicationSubmitterRepository submitterRepository;

    // REPLACE the getApprovedForOffer() method with this:
    public List<ApplicationDetailResponse> getApprovedForOffer() {
        // Get ALL applications where document verification is APPROVED
        // (regardless of offerStatus - could be IN_PROGRESS, APPROVED, or REJECTED)
        List<ApplicationStatus> approvedDocStatuses = statusRepository
                .findByDocumentVerificationStatus(ApplicationStatus.VerificationStatus.APPROVED);

        return approvedDocStatuses.stream().map(status -> {
            ApplicationDetails details = detailsRepository.findByAppId(status.getAppId()).orElse(null);
            ApplicationSubmitter submitter = submitterRepository.findById(status.getAppId()).orElse(null);

            if (details != null && submitter != null) {
                return mapToDetailResponse(submitter, details, status);
            }
            return null;
        }).filter(Objects::nonNull).collect(Collectors.toList());
    }

    public Map<String, Object> generateCreditScore(UUID appId) {
        ApplicationDetails details = detailsRepository.findByAppId(appId)
                .orElseThrow(() -> new RuntimeException("Application not found"));

        // Dummy credit score generation logic
        Random random = new Random();
        int creditScore = 300 + random.nextInt(551); // Score between 300-850

        String creditRating;
        if (creditScore >= 750) {
            creditRating = "Excellent";
        } else if (creditScore >= 700) {
            creditRating = "Good";
        } else if (creditScore >= 650) {
            creditRating = "Fair";
        } else if (creditScore >= 600) {
            creditRating = "Poor";
        } else {
            creditRating = "Very Poor";
        }

        Map<String, Object> creditInfo = new HashMap<>();
        creditInfo.put("appId", appId);
        creditInfo.put("fullName", details.getFullName());
        creditInfo.put("creditScore", creditScore);
        creditInfo.put("creditRating", creditRating);
        creditInfo.put("generatedAt", new Date());

        return creditInfo;
    }

    @Transactional
    public ApplicationDetailResponse processOffer(OfferGenerationRequest request) {
        ApplicationStatus status = statusRepository.findByAppId(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application not found"));

        // Check if document verification is approved
        if (status.getDocumentVerificationStatus() != ApplicationStatus.VerificationStatus.APPROVED) {
            throw new RuntimeException("Document verification must be approved before generating offer");
        }

        if ("APPROVED".equalsIgnoreCase(request.getAction())) {
            status.setOfferStatus(ApplicationStatus.OfferStatus.APPROVED);
            status.setOfferRejectReason(null);
        } else if ("REJECTED".equalsIgnoreCase(request.getAction())) {
            status.setOfferStatus(ApplicationStatus.OfferStatus.REJECTED);
            status.setOfferRejectReason(request.getRejectReason());
        } else {
            throw new RuntimeException("Invalid action. Use APPROVED or REJECTED");
        }

        statusRepository.save(status);

        ApplicationDetails details = detailsRepository.findByAppId(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application details not found"));
        ApplicationSubmitter submitter = submitterRepository.findById(request.getAppId())
                .orElseThrow(() -> new RuntimeException("Application submitter not found"));

        return mapToDetailResponse(submitter, details, status);
    }

    private ApplicationDetailResponse mapToDetailResponse(ApplicationSubmitter submitter,
                                                          ApplicationDetails details,
                                                          ApplicationStatus status) {
        ApplicationDetailResponse response = new ApplicationDetailResponse();
        response.setAppId(submitter.getAppId());
        response.setFullName(details.getFullName());
        response.setEmail(details.getEmail());
        response.setPhoneNumber(details.getPhoneNumber());
        response.setDateOfBirth(details.getDateOfBirth());
        response.setAddress(details.getAddress());

        // FIXED: Use filename getters instead of old getters
        response.setAadharFilename(details.getAadharFilename());
        response.setPanFilename(details.getPanFilename());
        response.setIncomeProofFilename(details.getIncomeProofFilename());

        // NEW: Set card type
        response.setCardType(details.getCardType() != null ? details.getCardType().name() : null);

        response.setDocumentVerificationStatus(status.getDocumentVerificationStatus().name());
        response.setOfferStatus(status.getOfferStatus().name());
        response.setSubmittedByRole(submitter.getSubmittedByRole().name());
        response.setSubmittedById(submitter.getSubmittedByUserOrSalesId());
        response.setSubmittedAt(submitter.getSubmittedAt());
        response.setUpdatedAt(status.getUpdatedAt());

        return response;
    }
}






package com.credit.backend.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;

@Component
public class JwtUtil {

    @Value("${jwt.secret:mySecretKeyForJWTTokenGenerationAndValidation12345}")
    private String secret;

    @Value("${jwt.expiration:86400000}") // 24 hours
    private Long expiration;

    private Key getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }

    public String extractEmail(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    private Claims extractAllClaims(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    public String generateToken(String email, UUID userId, String role) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId.toString());
        claims.put("role", role);
        return createToken(claims, email);
    }

    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(subject)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    public Boolean validateToken(String token, String email) {
        final String extractedEmail = extractEmail(token);
        return (extractedEmail.equals(email) && !isTokenExpired(token));
    }
}




package com.credit.backend.util;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Component;

@Component
public class PasswordEncoderUtil {

    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

    public String encode(String password) {
        return encoder.encode(password);
    }

    public boolean matches(String rawPassword, String encodedPassword) {
        return encoder.matches(rawPassword, encodedPassword);
    }
}




package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;

@SpringBootApplication(scanBasePackages = {"com.credit.backend"})
@EntityScan(basePackages = "com.credit.backend.model")
@EnableJpaRepositories(basePackages = "com.credit.backend.dao")
@EnableMethodSecurity // ADDED: Enable method-level security
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}


